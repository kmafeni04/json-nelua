require "io"
require "utf8"
require "traits"

local function pos_to_line_char(pos: integer, content: string)
  local s_line = 1
  local pos_at_line = 0
  local text = content:sub(1, pos)
  for line in text:gmatch("[^\r\n]*\r?\n") do
    pos_at_line = pos_at_line + #line
    s_line = s_line + 1
  end
  local s_char = pos - pos_at_line
  return s_line, s_char
end

local function unescape_str(str: string)
  str = str:gsub("\\n", "\n")  -- Newline  
  str = str:gsub("\\r", "\r")  -- Carriage return  
  str = str:gsub("\\t", "\t")  -- Tab  
  str = str:gsub("\\b", "\b")  -- Backspace  
  str = str:gsub("\\f", "\f")  -- Form Feed
  str = str:gsub('\\"', '"') -- Double quote  
  str = str:gsub("\\\\", "\\") -- Backslash  
  str = str:gsub("\\/", "/") -- Forwardslash  
  str = str:gsub("\\u(%x+)", function(h: string) -- Unicode characters
    return utf8.char(tonumber(h, 16))  
  end)  

  return str
end

local TokenType = @enum{
  NULL = 0,
  FALSE,
  TRUE,
  OPEN_BRACKET,
  CLOSE_BRACKET,
  OPEN_BRACE,
  CLOSE_BRACE,
  STRING,
  NUMBER,
  COMMA,
  COLON,
}

local Token = @record{
  val: string,
  type: TokenType,
  start_pos: uinteger,
  end_pos: uinteger
}

local function token_type_tostring(ttype: TokenType)
  switch ttype do
    case TokenType.NULL then
      return "NULL"
    case TokenType.FALSE then
      return "FALSE"
    case TokenType.TRUE then
      return "TRUE"
    case TokenType.OPEN_BRACKET then
      return "OPEN_BRACKET"
    case TokenType.CLOSE_BRACKET then
      return "CLOSE_BRACKET"
    case TokenType.OPEN_BRACE then
      return "OPEN_BRACE"
    case TokenType.CLOSE_BRACE then
      return "CLOSE_BRACE"
    case TokenType.STRING then
      return "STRING"
    case TokenType.NUMBER then
      return "NUMBER"
    case TokenType.COMMA then
      return "COMMA"
    case TokenType.COLON then
      return "COLON"
    else
      return ("ERROR: unknown token type `%d`"):format(ttype)
  end
end

local function tokenize(str: string)
  local tokens:sequence(Token)
  local index = 1

  while index ~= #str do
    local current_char = str:sub(index, index)
    if current_char == "[" then
      tokens:push({ val = current_char, type = TokenType.OPEN_BRACKET, start_pos = index, end_pos = index })
    elseif current_char == "]" then
      tokens:push({ val = current_char, type = TokenType.CLOSE_BRACKET, start_pos = index, end_pos = index })
    elseif current_char == "{" then
      tokens:push({ val = current_char, type = TokenType.OPEN_BRACE, start_pos = index, end_pos = index })
    elseif current_char == "}" then
      tokens:push({ val = current_char, type = TokenType.CLOSE_BRACE, start_pos = index, end_pos = index })
    elseif current_char:match("[%a_]") then
      local s_pos = index
      local val = current_char
      while str:sub(index + 1, index + 1):match("[%w_]") do
        val = val .. str:sub(index + 1, index + 1)
        index = index + 1
      end
      if val == "null" then
        tokens:push({ val = val, type = TokenType.NULL, start_pos = s_pos, end_pos = index })
      elseif val == "false" then
        tokens:push({ val = val, type = TokenType.FALSE, start_pos = s_pos, end_pos = index })
      elseif val == "true" then
        tokens:push({ val = val, type = TokenType.TRUE, start_pos = s_pos, end_pos = index })
      else
        goto ERROR
      end
    elseif current_char == '"' then
      local s_pos = index
      local val = ""
      while str:sub(index + 1, index + 1) ~= '"' do
        if str:sub(index + 1, index + 1) == "\\" then
          val = val .. "\\"
          if str:sub(index + 2, index + 2) == '"' then
            val = val .. '"'
            index = index + 1
          end
          index = index + 1
        end
        val = val .. str:sub(index + 1, index + 1)
        index = index + 1
      end
      val = unescape_str(val)
      index = index + 1
      tokens:push({ val = val, type = TokenType.STRING, start_pos = s_pos, end_pos = index })
    elseif current_char:match("[%-%d]") then
      local s_pos = index
      local val = current_char
      local decimal = false
      local exponent = false
      local after_exp = false
      local err = false
      while str:sub(index + 1, index + 1):match("[%d%.eE%-%+]") do
        local next_char = str:sub(index + 1, index + 1)

        if next_char == "." then
          if decimal then
            err = true
          end
          decimal = true
        elseif next_char:match("[eE]") then
          if exponent then
            err = true
          end
          exponent = true
          after_exp = true
        elseif after_exp and next_char:match("[^%-%+%d]") then
          err = true
        end
        val = val .. str:sub(index + 1, index + 1)
        index = index + 1
      end
      if current_char == "-" and #val == 1 then
        err = true
      end
      if val:match("^0%d") then
        err = true
      end
      if err then
        goto ERROR
      else
        tokens:push({ val = val, type = TokenType.NUMBER, start_pos = s_pos, end_pos = index })
      end
    elseif current_char == "," then
      tokens:push({ val = current_char, type = TokenType.COMMA, start_pos = index, end_pos = index })
    elseif current_char == ":" then
      tokens:push({ val = current_char, type = TokenType.COLON, start_pos = index, end_pos = index })
    elseif current_char:match("%s") then
    else
      goto ERROR
    end
    index = index + 1
  end

  return true, tokens, ""
  ::ERROR::
  local content = str:sub(1, index)
  local current_char = content:sub(index, index)
  local line, char = pos_to_line_char(index, content)
  return false, (@sequence(Token))({}), ("ERROR: Unknown token `%s` at line `%d`, character `%d`"):format(current_char, line, char)
end

local JsonNodeType = @enum{
  NULL = 0,
  BOOLEAN,
  STRING,
  NUMBER,
  ARRAY,
  OBJECT
}

local function json_node_type_tostring(jntype: JsonNodeType)
  switch jntype do
  case JsonNodeType.NULL then
    return "NULL"
  case JsonNodeType.BOOLEAN then
    return "BOOLEAN"
  case JsonNodeType.STRING then
    return "STRING"
  case JsonNodeType.NUMBER then
    return "NUMBER"
  case JsonNodeType.ARRAY then
    return "ARRAY"
  case JsonNodeType.OBJECT then
    return "OBJECT"
  end
  return ("ERROR: unknown type `%s`"):format(jntype)
end

local JsonNode = @record{
  val: union{
    null: niltype,
    bol: boolean,
    str: string,
    num: number,
    arr: sequence(JsonNode),
    obj: hashmap(string, JsonNode)
  },
  type: JsonNodeType
}

function JsonNode.new(node_type: JsonNodeType, value: overload(niltype, boolean, string, sequence(JsonNode), hashmap(string, JsonNode)))
  local node: JsonNode = {}
  node.type = node_type

  -- ##[[
  --   for k, v in pairs(value.type) do
  --     print(k, v)
  --   end
  --   print()
  -- ]]
  -- 
    ## print(value.type)

  ## if value.type.is_string then
    if node_type == JsonNodeType.NUMBER then
      node.val.num = tonumber(value)
      return true, node, ""
    end
    node.val.str = value
    return true, node, ""
  ## elseif value.type.is_hashmap then
    node.val.obj = value
    return true, node, ""
  ## end

  return false, (@JsonNode)({}), ("Invalid node type: `%d`"):format(node_type)
end

local parse_value: function(tokens: sequence(Token), index: uinteger): (boolean, JsonNode, string)

-- TODO: Properly show errors on trailing commas
-- TODO: Handle missing commas between fields
local function parse_object(tokens: sequence(Token), index: uinteger)
  local obj: hashmap(string, JsonNode)
  index = index + 1

  while index ~= #tokens do
    if tokens[index].type == TokenType.CLOSE_BRACE then
      return JsonNode.new(JsonNodeType.OBJECT, obj)
    end

    if tokens[index].type ~= TokenType.STRING then
      return false, (@JsonNode)({}), ("Expected `STRING`, got `%s`"):format(token_type_tostring(tokens[index].type))
    end 

    local key = tokens[index].val
    index = index + 1

    if tokens[index].type ~= TokenType.COLON then
      return false, (@JsonNode)({}), ("Expected `COLON`, got `%s`"):format(token_type_tostring(tokens[index].type))
    end 
    index = index + 1

    if tokens[index].type == TokenType.CLOSE_BRACE then
      return false, (@JsonNode)({}), ("Expected value, got `%s`"):format(token_type_tostring(tokens[index].type))
    end

    local ok, val, err = parse_value(tokens, index)

    if not ok then
      return ok, (@JsonNode)({}), err
    end

    obj[key] = val

    index = index + 1

    if tokens[index].type == TokenType.COMMA then
      index = index + 1
      if tokens[index].type == TokenType.CLOSE_BRACE then
        return false, (@JsonNode)({}), "Trailing comma"
      end
    end

  end

  return false, (@JsonNode)({}), "Unclosed object"
end

function parse_value(tokens: sequence(Token), index: uinteger)

  local ok: boolean
  local node: JsonNode
  local err: string

  local token = tokens[index]
  if token.type == TokenType.OPEN_BRACE then
    ok, node, err = parse_object(tokens, index)
  elseif token.type == TokenType.STRING then
    ok, node, err = JsonNode.new(JsonNodeType.STRING, token.val)
  elseif token.type == TokenType.NUMBER then
    ok, node, err = JsonNode.new(JsonNodeType.NUMBER, token.val)
  else
    return false, (@JsonNode)({}), ("UNIMPLEMENTED: `%s`"):format(token_type_tostring(tokens[index].type))
  end
  return ok, node, err
end

local function parse(content: string)
  local ok, tokens, err = tokenize(content)

  -- for _, token in ipairs(tokens) do
    -- print(token.val, token_type_tostring(token.type))
  -- end

  if not ok then
    return ok, (@JsonNode)({}), err
  end

  local ok, node, err = parse_value(tokens, 1)

  if not ok then
    return false, (@JsonNode)({}), err
  end

  return true, node, ""
end

-- local file, err = io.open("test.json")

-- assert(file:isopen(), ("Failed to open file: %s"):format(err))

-- local content, err = file:read("a")

-- assert(err == "", err)

local content = [[
  {
    "properties": {
      "test": 6.02e-23,
      "test2": {
        "test3": 11
      }
    }
  }
]]

local ok, node, err = parse(content)


assert(ok, err)

-- print(node.val.obj["properties"].val.obj["test"].val.num)
-- print(node.val.obj["properties"].val.obj["test2"].val.obj["test3"].val.num)


