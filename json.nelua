require "io"
require "utf8"
require "traits"
require "allocators.default"

local function pos_to_line_char(pos: integer, content: string)
  local s_line = 1
  local pos_at_line = 0
  local text = content:sub(1, pos)
  for line in text:gmatch("[^\r\n]*\r?\n") do
    pos_at_line = pos_at_line + #line
    s_line = s_line + 1
  end
  local s_char = pos - pos_at_line
  return s_line, s_char
end

local function unescape_str(str: string)
  str = str:gsub("\\n", "\n")  -- Newline  
  str = str:gsub("\\r", "\r")  -- Carriage return  
  str = str:gsub("\\t", "\t")  -- Tab  
  str = str:gsub("\\b", "\b")  -- Backspace  
  str = str:gsub("\\f", "\f")  -- Form Feed
  str = str:gsub('\\"', '"') -- Double quote  
  str = str:gsub("\\\\", "\\") -- Backslash  
  str = str:gsub("\\/", "/") -- Forwardslash  
  str = str:gsub("\\u(%x+)", function(h: string) -- Unicode characters
    return utf8.char(tonumber(h, 16))  
  end)  

  return str
end

local TokenType = @enum{
  NULL = 0,
  FALSE,
  TRUE,
  OPEN_BRACKET,
  CLOSE_BRACKET,
  OPEN_BRACE,
  CLOSE_BRACE,
  STRING,
  NUMBER,
  COMMA,
  COLON,
  EOF
}

local Token = @record{
  val: string,
  type: TokenType,
  start_pos: uinteger,
  end_pos: uinteger
}

local function token_type_tostring(ttype: TokenType)
  switch ttype do
    case TokenType.NULL then
      return "NULL"
    case TokenType.FALSE then
      return "FALSE"
    case TokenType.TRUE then
      return "TRUE"
    case TokenType.OPEN_BRACKET then
      return "OPEN_BRACKET"
    case TokenType.CLOSE_BRACKET then
      return "CLOSE_BRACKET"
    case TokenType.OPEN_BRACE then
      return "OPEN_BRACE"
    case TokenType.CLOSE_BRACE then
      return "CLOSE_BRACE"
    case TokenType.STRING then
      return "STRING"
    case TokenType.NUMBER then
      return "NUMBER"
    case TokenType.COMMA then
      return "COMMA"
    case TokenType.COLON then
      return "COLON"
    case TokenType.EOF then
      return "EOF"
    else
      return ("Unknown token type `%d`"):format(ttype)
  end
end

local function tokenize(str: string)
  local tokens:sequence(Token)
  local index = 1

  while index <= #str do
    local current_char = str:sub(index, index)
    if current_char == "[" then
      tokens:push({ val = current_char, type = TokenType.OPEN_BRACKET, start_pos = index, end_pos = index })
    elseif current_char == "]" then
      tokens:push({ val = current_char, type = TokenType.CLOSE_BRACKET, start_pos = index, end_pos = index })
    elseif current_char == "{" then
      tokens:push({ val = current_char, type = TokenType.OPEN_BRACE, start_pos = index, end_pos = index })
    elseif current_char == "}" then
      tokens:push({ val = current_char, type = TokenType.CLOSE_BRACE, start_pos = index, end_pos = index })
    elseif current_char:match("[%a_]") then
      local s_pos = index
      local val = current_char
      while str:sub(index + 1, index + 1):match("[%w_]") do
        val = val .. str:sub(index + 1, index + 1)
        index = index + 1
      end
      if val == "null" then
        tokens:push({ val = val, type = TokenType.NULL, start_pos = s_pos, end_pos = index })
      elseif val == "false" then
        tokens:push({ val = val, type = TokenType.FALSE, start_pos = s_pos, end_pos = index })
      elseif val == "true" then
        tokens:push({ val = val, type = TokenType.TRUE, start_pos = s_pos, end_pos = index })
      else
        goto ERROR
      end
    elseif current_char == '"' then
      local s_pos = index
      local val = ""
      while str:sub(index + 1, index + 1) ~= '"' do
        if str:sub(index + 1, index + 1) == "\\" then
          val = val .. "\\"
          if str:sub(index + 2, index + 2) == '"' then
            val = val .. '"'
            index = index + 1
          end
          index = index + 1
        end
        val = val .. str:sub(index + 1, index + 1)
        index = index + 1
      end
      val = unescape_str(val)
      index = index + 1
      tokens:push({ val = val, type = TokenType.STRING, start_pos = s_pos, end_pos = index })
    elseif current_char:match("[%-%d]") then
      local s_pos = index
      local val = current_char
      local decimal = false
      local exponent = false
      local after_exp = false
      local err = false
      while str:sub(index + 1, index + 1):match("[%d%.eE%-%+]") do
        local next_char = str:sub(index + 1, index + 1)

        if next_char == "." then
          if decimal then
            err = true
          end
          decimal = true
        elseif next_char:match("[eE]") then
          if exponent then
            err = true
          end
          exponent = true
          after_exp = true
        elseif after_exp and next_char:match("[^%-%+%d]") then
          err = true
        end
        val = val .. str:sub(index + 1, index + 1)
        index = index + 1
      end
      if current_char == "-" and #val == 1 then
        err = true
      end
      if val:match("^0%d") then
        err = true
      end
      if err then
        goto ERROR
      else
        tokens:push({ val = val, type = TokenType.NUMBER, start_pos = s_pos, end_pos = index })
      end
    elseif current_char == "," then
      tokens:push({ val = current_char, type = TokenType.COMMA, start_pos = index, end_pos = index })
    elseif current_char == ":" then
      tokens:push({ val = current_char, type = TokenType.COLON, start_pos = index, end_pos = index })
    elseif current_char:match("%s") then
    else
      goto ERROR
    end
    index = index + 1
  end

  tokens:push({ val = "", type = TokenType.EOF, start_pos = #str + 1, end_pos = #str + 1 })
  return true, tokens, ""
  ::ERROR::
  local content = str:sub(1, index)
  local current_char = content:sub(index, index)
  local line, char = pos_to_line_char(index, content)
  return false, (@sequence(Token))({}), ("[%d:%d]: Unknown token `%s`"):format(line, char, current_char)
end

local JsonNodeType = @enum{
  NULL = 0,
  BOOLEAN,
  STRING,
  NUMBER,
  ARRAY,
  OBJECT
}

local function json_node_type_tostring(jntype: JsonNodeType)
  switch jntype do
  case JsonNodeType.NULL then
    return "NULL"
  case JsonNodeType.BOOLEAN then
    return "BOOLEAN"
  case JsonNodeType.STRING then
    return "STRING"
  case JsonNodeType.NUMBER then
    return "NUMBER"
  case JsonNodeType.ARRAY then
    return "ARRAY"
  case JsonNodeType.OBJECT then
    return "OBJECT"
  end
  return ("Unknown type `%s`"):format(jntype)
end

local JsonNode = @record{
  val: union{
    null: niltype,
    bol: boolean,
    str: string,
    num: number,
    arr: sequence(JsonNode),
    obj: hashmap(string, JsonNode)
  },
  type: JsonNodeType
}

function JsonNode.new(node_type: JsonNodeType, value: overload(string, sequence(JsonNode), hashmap(string, JsonNode))): (boolean, JsonNode, string)
  local node: JsonNode = {}
  node.type = node_type

  ## if value.type.is_string then
    if node_type == JsonNodeType.NUMBER then
      node.val.num = tonumber(value)
    elseif node_type == JsonNodeType.BOOLEAN then
      node.val.bol = true and value == "true" or false
    elseif node_type == JsonNodeType.NULL then
      node.val.null = nil
    else
      node.val.str = value
    end
    return true, node, ""
  ## elseif value.type.is_hashmap then
    node.val.obj = value
    return true, node, ""
  ## elseif value.type.is_sequence then
    node.val.arr = value
    return true, node, ""
  ## end

  return false, (@JsonNode)({}), ("Invalid node type `%d`"):format(node_type)
end

function JsonNode:is(node_type: JsonNodeType): boolean
  return true and self.type == node_type or false
end

local Parser = @record{
  content: string,
  tokens: sequence(Token),
  index: *uinteger
}

function Parser.new(content: string): (boolean, Parser, string)
  local ok, tokens, err = tokenize(content)

  if not ok then
    return false, (@Parser)(), err
  end

  local parser: Parser

  parser.content = content
  parser.tokens = tokens
  parser.index = (@*uinteger)(default_allocator:alloc(#uinteger))
  $(parser.index) = 1

  return true, parser, ""
end

local Parser.parse_from_token: function(self: Parser, token: Token): (boolean, JsonNode, string)
local Parser.parse_object: function(self: Parser):(boolean, JsonNode, string)
local Parser.parse_array: function(self: Parser):(boolean, JsonNode, string)

function Parser:peek()
  local index = $(self.index) 
  if index <= #self.tokens then
    return self.tokens[index]
  end
  return (@Token)({ val = "", type = TokenType.EOF, start_pos = #self.content + 1, end_pos = #self.content + 1 })
end

function Parser:peek_next(): Token
  local index = $(self.index) 
  if index + 1 <= #self.tokens then
    return self.tokens[index + 1]
  end
  return (@Token)({ val = "", type = TokenType.EOF, start_pos = #self.content + 1, end_pos = #self.content + 1 })
end

function Parser:advance()
  local index = self.index
  if $index <= #self.tokens then
    local current_token = self.tokens[$index]
    $index = $index + 1
    return current_token
  end
  return (@Token)({ val = "", type = TokenType.EOF, start_pos = #self.content + 1, end_pos = #self.content + 1 })
end

function Parser:advance_comma_unless(ttype: TokenType): (boolean, Token, string)
  if self:peek().type == TokenType.COMMA then
      if self.tokens[$self.index + 1].type == ttype or self.tokens[$self.index + 1].type == TokenType.EOF then
        local line, char = pos_to_line_char(self:peek().start_pos, self.content)
        return false, self:peek(), ("[%d:%d]: Trailing comma"):format(line, char)
      end
    return true, self:advance(), ""
  end

  if self:peek().type ~= ttype and self:peek().type ~= TokenType.EOF then
    local ttype_str = token_type_tostring(self:peek().type)
    local line, char = pos_to_line_char(self:peek().start_pos, self.content)
    return false, self:peek() ,("[%d:%d]: Expected `COMMA`, got `%s`"):format(line, char, ttype_str)
  end

  return true, self:peek() ,""
end

Parser.parse_from_token = function(self:Parser, token: Token)
  switch token.type do
    case TokenType.OPEN_BRACE then
      return self:parse_object()
    case TokenType.OPEN_BRACKET then
      return self:parse_array()
    case TokenType.STRING then
      return JsonNode.new(JsonNodeType.STRING, token.val)
    case TokenType.NUMBER then
      return JsonNode.new(JsonNodeType.NUMBER, token.val)
    case TokenType.TRUE then
      return JsonNode.new(JsonNodeType.BOOLEAN, token.val)
    case TokenType.FALSE then
      return JsonNode.new(JsonNodeType.BOOLEAN, token.val)
    case TokenType.NULL then
      return JsonNode.new(JsonNodeType.NULL, token.val)
    else
      return false, (@JsonNode)({}), ("UNREACHABLE: `%s`"):format(token_type_tostring(token.type))
  end
    return false, (@JsonNode)({}), token_type_tostring(token.type)
end

Parser.parse_object = function(self: Parser): (boolean, JsonNode, string)
  local obj: hashmap(string, JsonNode)
  self:advance()

  while self:peek().type ~= TokenType.CLOSE_BRACE do

    if self:peek().type == TokenType.EOF then
      local line, char = pos_to_line_char(self:peek().start_pos, self.content)
      return false, (@JsonNode)({}), ("[%d:%d]: Unclosed object"):format(line, char)
    end

    -- Expect Key
    if self:peek().type ~= TokenType.STRING then
      local ttype = token_type_tostring(self:peek().type)
      local line, char = pos_to_line_char(self:peek().start_pos, self.content)
      return false, (@JsonNode)({}), ("[%d:%d]: Expected `STRING`, got `%s`"):format(line, char, ttype)
    end 

    local key = self:peek().val

    -- Duplicate fields check
    if obj:has(key) then
      local line, char = pos_to_line_char(self:peek().start_pos, self.content)
      return false, (@JsonNode)({}), ("[%d:%d]: Duplicate field `%s`"):format(line, char, key)
    end
    self:advance()

    -- Expect colon
    if self:peek().type ~= TokenType.COLON then
      local ttype = token_type_tostring(self:peek().type)
      local line, char = pos_to_line_char(self:peek().start_pos, self.content)
      return false, (@JsonNode)({}), ("[%d:%d]: Expected `COLON`, got `%s`"):format(line, char, ttype)
    end 
    self:advance()

    local ok, val, err = self:parse_from_token(self:peek())

    if not ok then
      return ok, (@JsonNode)({}), err
    end
    obj[key] = val
    self:advance()


    local ok, token, err = self:advance_comma_unless(TokenType.CLOSE_BRACE)
    
    if not ok then
      return ok, (@JsonNode)({}), err
    end

  end

  return JsonNode.new(JsonNodeType.OBJECT, obj)
end

Parser.parse_array = function(self: Parser): (boolean, JsonNode, string)
  local arr: sequence(JsonNode)
  self:advance()

  while self:peek().type ~= TokenType.CLOSE_BRACKET do

    if self:peek().type == TokenType.EOF then
      local line, char = pos_to_line_char(self:peek().start_pos, self.content)
      return false, (@JsonNode)({}), ("[%d:%d]: Unclosed array"):format(line, char)
    end

    local ok, val, err = self:parse_from_token(self:peek())

    if not ok then
      return ok, (@JsonNode)({}), err
    end

    arr:push(val)
    self:advance()

    local ok, token, err = self:advance_comma_unless(TokenType.CLOSE_BRACKET)
    
    if not ok then
      return ok, (@JsonNode)({}), err
    end

  end

  return JsonNode.new(JsonNodeType.ARRAY, arr)
end

function Parser:parse(): (boolean, JsonNode, string)
  return self:parse_from_token(self:peek())
end


-- local file, err = io.open("test.json")

-- assert(file:isopen(), ("Failed to open file: %s"):format(err))

-- local content, err = file:read("a")

-- assert(err == "", "ERROR: " .. err)

local content = [[
  {
    "name": "James"
  }
]]

local ok, parser, err = Parser.new(content)

assert(ok, err)

local ok, node, err = parser:parse()

assert(ok, err)

node:get(JsonNodeType.OBJECT)

local json = @record{}

local json.Parser = Parser
