require "io"
require "utf8"
require "traits"

local function pos_to_line_char(pos: integer, content: string)
  local s_line = 1
  local pos_at_line = 0
  local text = content:sub(1, pos)
  for line in text:gmatch("[^\r\n]*\r?\n") do
    pos_at_line = pos_at_line + #line
    s_line = s_line + 1
  end
  local s_char = pos - pos_at_line
  return s_line, s_char
end

local function unescape_str(str: string)
  str = str:gsub("\\n", "\n") 
  str = str:gsub("\\r", "\r")  
  str = str:gsub("\\t", "\t")
  str = str:gsub("\\b", "\b")
  str = str:gsub("\\f", "\f")
  str = str:gsub('\\"', '"')
  str = str:gsub("\\\\", "\\")
  str = str:gsub("\\/", "/")
  str = str:gsub("\\u(%x+)", function(h: string)
    return utf8.char(tonumber(h, 16))  
  end)

  return str
end

local TokenType = @enum{
  NULL = 0,
  FALSE,
  TRUE,
  OPEN_BRACKET,
  CLOSE_BRACKET,
  OPEN_BRACE,
  CLOSE_BRACE,
  STRING,
  NUMBER,
  COMMA,
  COLON,
  EOF
}

local Token = @record{
  val: string,
  type: TokenType,
  start_pos: uinteger,
  end_pos: uinteger
}

local function token_type_tostring(ttype: TokenType)
  switch ttype do
    case TokenType.NULL then
      return "NULL"
    case TokenType.FALSE then
      return "FALSE"
    case TokenType.TRUE then
      return "TRUE"
    case TokenType.OPEN_BRACKET then
      return "OPEN_BRACKET"
    case TokenType.CLOSE_BRACKET then
      return "CLOSE_BRACKET"
    case TokenType.OPEN_BRACE then
      return "OPEN_BRACE"
    case TokenType.CLOSE_BRACE then
      return "CLOSE_BRACE"
    case TokenType.STRING then
      return "STRING"
    case TokenType.NUMBER then
      return "NUMBER"
    case TokenType.COMMA then
      return "COMMA"
    case TokenType.COLON then
      return "COLON"
    case TokenType.EOF then
      return "EOF"
    else
      return ("ERROR: unknown token type `%d`"):format(ttype)
  end
end

-- Define a helper that increments an integer via its pointer.
local function advance_index_ptr(p: *integer)
  $p = $p + 1
end

local function tokenize(str: string)
  local tokens:sequence(Token)
  local index = 1

  while index <= #str do
    local current_char = str:sub(index, index)
    if current_char == "[" then
      tokens:push({ val = current_char, type = TokenType.OPEN_BRACKET, start_pos = index, end_pos = index })
      advance_index_ptr(&index)  -- increment index
    elseif current_char == "]" then
      tokens:push({ val = current_char, type = TokenType.CLOSE_BRACKET, start_pos = index, end_pos = index })
      advance_index_ptr(&index)
    elseif current_char == "{" then
      tokens:push({ val = current_char, type = TokenType.OPEN_BRACE, start_pos = index, end_pos = index })
      advance_index_ptr(&index)
    elseif current_char == "}" then
      tokens:push({ val = current_char, type = TokenType.CLOSE_BRACE, start_pos = index, end_pos = index })
      advance_index_ptr(&index)
    elseif current_char:match("[%a_]") then
      local s_pos = index
      local val = current_char
      advance_index_ptr(&index)
      while index <= #str and str:sub(index, index):match("[%w_]") do
        val = val .. str:sub(index, index)
        advance_index_ptr(&index)
      end
      if val == "null" then
        tokens:push({ val = val, type = TokenType.NULL, start_pos = s_pos, end_pos = index - 1 })
      elseif val == "false" then
        tokens:push({ val = val, type = TokenType.FALSE, start_pos = s_pos, end_pos = index - 1 })
      elseif val == "true" then
        tokens:push({ val = val, type = TokenType.TRUE, start_pos = s_pos, end_pos = index - 1 })
      else
        goto ERROR
      end
    elseif current_char == '"' then
      local s_pos = index
      local val = ""
      advance_index_ptr(&index)  -- skip the starting "
      while index <= #str and str:sub(index, index) ~= '"' do
        local ch = str:sub(index, index)
        if ch == "\\" then
          local escape_seq = str:sub(index, index+1)
          val = val .. escape_seq
          advance_index_ptr(&index)
          advance_index_ptr(&index)
        else
          val = val .. ch
          advance_index_ptr(&index)
        end
      end
      val = unescape_str(val)
      advance_index_ptr(&index)  -- skip the ending "
      tokens:push({ val = val, type = TokenType.STRING, start_pos = s_pos, end_pos = index - 1 })
    elseif current_char:match("[%-%d]") then
      local s_pos = index
      local val = current_char
      advance_index_ptr(&index)
      local decimal = false
      local exponent = false
      local after_exp = false
      local err = false
      while index <= #str and str:sub(index, index):match("[%d%.eE%-%+]") do
        local next_char = str:sub(index, index)
        if next_char == "." then
          if decimal then err = true end
          decimal = true
        elseif next_char:match("[eE]") then
          if exponent then err = true end
          exponent = true
          after_exp = true
        elseif after_exp and not next_char:match("[%d]") and (next_char ~= "-" and next_char ~= "+") then
          err = true
        end
        val = val .. next_char
        advance_index_ptr(&index)
      end
      if current_char == "-" and #val == 1 then
        err = true
      end
      if val:match("^0%d") then
        err = true
      end
      if err then
        goto ERROR
      else
        tokens:push({ val = val, type = TokenType.NUMBER, start_pos = s_pos, end_pos = index - 1 })
      end
    elseif current_char == "," then
      tokens:push({ val = current_char, type = TokenType.COMMA, start_pos = index, end_pos = index })
      advance_index_ptr(&index)
    elseif current_char == ":" then
      tokens:push({ val = current_char, type = TokenType.COLON, start_pos = index, end_pos = index })
      advance_index_ptr(&index)
    elseif current_char:match("%s") then
      advance_index_ptr(&index)
    else
      goto ERROR
    end
  end

  tokens:push({ val = "", type = TokenType.EOF, start_pos = #str + 1, end_pos = #str + 1 })
  return true, tokens, ""
  ::ERROR::
  local content = str:sub(1, index)
  local current_char = content:sub(index, index)
  local line, char = pos_to_line_char(index, content)
  return false, (@sequence(Token))({}), ("ERROR: Unknown token `%s` at line `%d`, character `%d`"):format(current_char, line, char)
end

local JsonNodeType = @enum{
  NULL = 0,
  BOOLEAN,
  STRING,
  NUMBER,
  ARRAY,
  OBJECT
}

local function json_node_type_tostring(jntype: JsonNodeType)
  switch jntype do
  case JsonNodeType.NULL then
    return "NULL"
  case JsonNodeType.BOOLEAN then
    return "BOOLEAN"
  case JsonNodeType.STRING then
    return "STRING"
  case JsonNodeType.NUMBER then
    return "NUMBER"
  case JsonNodeType.ARRAY then
    return "ARRAY"
  case JsonNodeType.OBJECT then
    return "OBJECT"
  end
  return ("ERROR: unknown type `%s`"):format(jntype)
end

local JsonNode = @record{
  val: union{
    null: niltype,
    bol: boolean,
    str: string,
    num: number,
    arr: sequence(JsonNode),
    obj: hashmap(string, JsonNode)
  },
  type: JsonNodeType
}

function JsonNode.new(node_type: JsonNodeType, value: overload(niltype, boolean, string, number, sequence(JsonNode), hashmap(string, JsonNode))): (boolean, JsonNode, string)
  local node: JsonNode = {}
  node.type = node_type

  ## if value.type.is_niltype then
    if node_type == JsonNodeType.NULL then
      node.val.null = (@niltype)()
      return true, node, ""
    end
  ## elseif value.type.is_boolean then
    if node_type == JsonNodeType.BOOLEAN then
      node.val.bol = value
      return true, node, ""
    end
  ## elseif value.type.is_string then
    if node_type == JsonNodeType.STRING then
      node.val.str = value
      return true, node, ""
    elseif node_type == JsonNodeType.NUMBER then
      node.val.num = tonumber(value)
      return true, node, ""
    end
  ## elseif value.type.is_sequence then
    if node_type == JsonNodeType.ARRAY then
      node.val.arr = value
      return true, node, ""
    end
  ## elseif value.type.is_hashmap then
    if node_type == JsonNodeType.OBJECT then
      node.val.obj = value
      return true, node, ""
    end
  ## end

  return false, (@JsonNode)({}), ("Invalid node type: `%d`"):format(node_type)
end

local Parser = @record{
  content: string,
  tokens: sequence(Token),
  index: uinteger
}

function Parser.new(content: string): (boolean, Parser, string)
  local ok, tokens, err = tokenize(content)

  if not ok then
    return false, (@Parser)(), err
  end

  local parser: Parser

  parser.content = content
  parser.tokens = tokens
  parser.index = 1

  return true, parser, ""
end

local Parser.parse_from_token: function(self: Parser, token: Token): (boolean, JsonNode, string)
local Parser.parse_object: function(self: Parser):(boolean, JsonNode, string)
local Parser.parse_array: function(self: Parser):(boolean, JsonNode, string)

function Parser:peek(): Token
  if self.index <= #self.tokens then
    return self.tokens[self.index]
  end
  return (@Token){ val = "", type = TokenType.EOF, start_pos = #self.content + 1, end_pos = #self.content + 1 }
end

function Parser:peek_next(): Token
  if self.index + 1 <= #self.tokens then
    return self.tokens[self.index + 1]
  end
  return (@Token){ val = "", type = TokenType.EOF, start_pos = #self.content + 1, end_pos = #self.content + 1 }
end

function Parser:advance(): Token
  self.index = self.index + 1
  if self.index <= #self.tokens then
    return self.tokens[self.index]
  end
  return (@Token){ val = "", type = TokenType.EOF, start_pos = #self.content + 1, end_pos = #self.content + 1 }
end

function Parser:advance_comma_unless(ttype: TokenType): (boolean, Token, string)
  if self:peek().type == TokenType.COMMA then
    return true, self:advance(), ""
  end

  if self:peek().type ~= ttype then
    local ttype_str = token_type_tostring(self:peek().type)
    return false, self:peek() ,("Expected `COMMA`, got `%s`"):format(ttype_str)
  end

  return true, self:advance() ,""
end

Parser.parse_from_token = function(self:Parser, token: Token)
  switch token.type do
    case TokenType.OPEN_BRACE then
      return self:parse_object()
    case TokenType.OPEN_BRACKET then
      return self:parse_array()
    case TokenType.STRING then
      local val = token.val
      self:advance()
      return JsonNode.new(JsonNodeType.STRING, val)
    case TokenType.NUMBER then
      local val = token.val
      self:advance() 
      return JsonNode.new(JsonNodeType.NUMBER, val)
    case TokenType.NULL then
      self:advance() 
      return JsonNode.new(JsonNodeType.NULL, (@niltype)())
    case TokenType.TRUE then
      self:advance() 
      return JsonNode.new(JsonNodeType.BOOLEAN, true)
    case TokenType.FALSE then
      self:advance() 
      return JsonNode.new(JsonNodeType.BOOLEAN, false)
    else
      return false, (@JsonNode)({}), ("UNIMPLEMENTED: `%s`"):format(token_type_tostring(token.type))
  end
end

Parser.parse_array = function(self: Parser): (boolean, JsonNode, string)
  local arr: sequence(JsonNode)
  
  if self:peek().type ~= TokenType.OPEN_BRACKET then
    return false, (@JsonNode)({}), ("Expected `OPEN_BRACKET`, got `%s`"):format(token_type_tostring(self:peek().type))
  end
  self:advance()

  if self:peek().type == TokenType.CLOSE_BRACKET then
    self:advance()
    return JsonNode.new(JsonNodeType.ARRAY, arr)
  end

  while true do
    local ok, val, err = self:parse_from_token(self:peek())
    if not ok then
      return ok, (@JsonNode)({}), err
    end
    
    arr:push(val)

    if self:peek().type == TokenType.CLOSE_BRACKET then
      self:advance()
      break
    elseif self:peek().type ~= TokenType.COMMA then
      return false, (@JsonNode)({}), ("Expected `COMMA` or `CLOSE_BRACKET`, got `%s`"):format(token_type_tostring(self:peek().type))
    end
    self:advance()
  end

  return JsonNode.new(JsonNodeType.ARRAY, arr)
end

-- TODO: Properly show errors on trailing commas
-- TODO: Handle missing commas between fields
Parser.parse_object = function(self: Parser): (boolean, JsonNode, string)
  local obj: hashmap(string, JsonNode)
  if self:peek().type ~= TokenType.OPEN_BRACE then
    return false, (@JsonNode)({}), ("Expected `OPEN_BRACE`, got `%s`"):format(token_type_tostring(self:peek().type))
  end
  self:advance()

  if self:peek().type == TokenType.CLOSE_BRACE then
    self:advance() 
    return JsonNode.new(JsonNodeType.OBJECT, obj)
  end

  local current_token = self:peek()
  if current_token.type ~= TokenType.STRING then
    local line, char = pos_to_line_char(current_token.start_pos, self.content)
    return false, (@JsonNode)({}), ("Expected object key `STRING` at line %d, character %d, got `%s`"):format(
      line, char, token_type_tostring(current_token.type))
  end
  local key = current_token.val
  self:advance()

  current_token = self:peek()
  if current_token.type ~= TokenType.COLON then
    local line, char = pos_to_line_char(current_token.start_pos, self.content)
    return false, (@JsonNode)({}), ("Expected `COLON` after object key at line %d, character %d, got `%s`"):format(
      line, char, token_type_tostring(current_token.type))
  end
  self:advance()

  local ok, val, err = self:parse_from_token(self:peek())
  if not ok then
      return ok, (@JsonNode)({}), err
  end
  obj[key] = val

  while true do
    if self:peek().type == TokenType.COMMA then
      self:advance()
      if self:peek().type == TokenType.CLOSE_BRACE then
        break
      end

      current_token = self:peek()
      if current_token.type ~= TokenType.STRING then
        local line, char = pos_to_line_char(current_token.start_pos, self.content)
        return false, (@JsonNode)({}), ("Expected object key after COMMA at line %d, character %d, got `%s`"):format(
          line, char, token_type_tostring(current_token.type))
      end
      key = current_token.val
      self:advance()

      current_token = self:peek()
      if current_token.type ~= TokenType.COLON then
        local line, char = pos_to_line_char(current_token.start_pos, self.content)
        return false, (@JsonNode)({}), ("Expected `COLON` after object key at line %d, character %d, got `%s`"):format(
          line, char, token_type_tostring(current_token.type))
      end
      self:advance()

      local ok, val, err = self:parse_from_token(self:peek())
      if not ok then
        return ok, (@JsonNode)({}), err
      end
      obj[key] = val
    else
      break
    end
  end

  self:advance()

  return JsonNode.new(JsonNodeType.OBJECT, obj)
end

function Parser:parse(): (boolean, JsonNode, string)
  return self:parse_from_token(self:peek())
end

local function repeat_str(str: string, n: integer): string
  local s = ""
  for i=1,n do
    s = s .. str
  end
  return s
end

local function pretty_print(node: JsonNode, indent: integer)
  indent = indent or 0
  local indent_str = repeat_str("  ", indent)

  switch node.type do
    case JsonNodeType.OBJECT then
      io.write("{\n")
      local first = true
      for key, value in pairs(node.val.obj) do
        if not first then
          io.write(",\n")
        end
        first = false
        io.write(indent_str .. "  \"" .. key .. "\": ")
        pretty_print(value, indent + 1)
      end
      if not first then
        io.write("\n")
      end
      io.write(indent_str .. "}")

    case JsonNodeType.ARRAY then
      io.write("[\n")
      local first = true
      for i, value in ipairs(node.val.arr) do
        if not first then
          io.write(",\n")
        end
        first = false
        io.write(indent_str .. "  ")
        pretty_print(value, indent + 1)
      end
      if not first then
        io.write("\n")
      end
      io.write(indent_str .. "]")

    case JsonNodeType.STRING then
      io.write("\"" .. node.val.str .. "\"")

    case JsonNodeType.NUMBER then
      io.write(tostring(node.val.num))

    case JsonNodeType.BOOLEAN then
      io.write(tostring(node.val.bol))

    case JsonNodeType.NULL then
      io.write("null")

    else
      io.write("\"<unknown>\"")
  end
  io.write("\n")
end

local file, err = io.open("test.json")
assert(file:isopen(), ("Failed to open file: %s"):format(err))
local content, err = file:read("a")
assert(err == "", err)
print(content)
local ok, parser, err = Parser.new(content)
assert(ok, err)
local ok, node, err = parser:parse()
assert(ok, err)
pretty_print(node, 0)