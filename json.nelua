require "io"
require "utf8"
require "traits"

local function pos_to_line_char(pos: integer, content: string)
  local s_line = 1
  local pos_at_line = 0
  local text = content:sub(1, pos)
  for line in text:gmatch("[^\r\n]*\r?\n") do
    pos_at_line = pos_at_line + #line
    s_line = s_line + 1
  end
  local s_char = pos - pos_at_line
  return s_line, s_char
end

local function unescape_str(str: string)
  str = str:gsub("\\n", "\n")  -- Newline  
  str = str:gsub("\\r", "\r")  -- Carriage return  
  str = str:gsub("\\t", "\t")  -- Tab  
  str = str:gsub("\\b", "\b")  -- Backspace  
  str = str:gsub("\\f", "\f")  -- Form Feed
  str = str:gsub('\\"', '"') -- Double quote  
  str = str:gsub("\\\\", "\\") -- Backslash  
  str = str:gsub("\\/", "/") -- Forwardslash  
  str = str:gsub("\\u(%x+)", function(h: string) -- Unicode characters
    return utf8.char(tonumber(h, 16))  
  end)  

  return str
end

local TokenType = @enum{
  NULL = 0,
  FALSE,
  TRUE,
  OPEN_BRACKET,
  CLOSE_BRACKET,
  OPEN_BRACE,
  CLOSE_BRACE,
  STRING,
  NUMBER,
  COMMA,
  COLON,
}

local Token = @record{
  val: string,
  type: TokenType
}

local function token_type_tostring(ttype: TokenType)
  switch ttype do
    case TokenType.NULL then
      return "NULL"
    case TokenType.FALSE then
      return "FALSE"
    case TokenType.TRUE then
      return "TRUE"
    case TokenType.OPEN_BRACKET then
      return "OPEN_BRACKET"
    case TokenType.CLOSE_BRACKET then
      return "CLOSE_BRACKET"
    case TokenType.OPEN_BRACE then
      return "OPEN_BRACE"
    case TokenType.CLOSE_BRACE then
      return "CLOSE_BRACE"
    case TokenType.STRING then
      return "STRING"
    case TokenType.NUMBER then
      return "NUMBER"
    case TokenType.COMMA then
      return "COMMA"
    case TokenType.COLON then
      return "COLON"
    else
      return ("ERROR: unknown token type `%d`"):format(ttype)
  end
end

local function tokenize(str: string)
  local tokens:sequence(Token)
  local index = 1

  while index ~= #str do
    local current_char = str:sub(index, index)
    if current_char == "[" then
      tokens:push({ val = current_char, type = TokenType.OPEN_BRACKET})
    elseif current_char == "]" then
      tokens:push({ val = current_char, type = TokenType.CLOSE_BRACKET})
    elseif current_char == "{" then
      tokens:push({ val = current_char, type = TokenType.OPEN_BRACE})
    elseif current_char == "}" then
      tokens:push({ val = current_char, type = TokenType.CLOSE_BRACE})
    elseif current_char:match("[%a_]") then
      local val = current_char
      while str:sub(index + 1, index + 1):match("[%w_]") do
        val = val .. str:sub(index + 1, index + 1)
        index = index + 1
      end
      if val == "null" then
        tokens:push({ val = val, type = TokenType.NULL})
      elseif val == "false" then
        tokens:push({ val = val, type = TokenType.FALSE})
      elseif val == "true" then
        tokens:push({ val = val, type = TokenType.TRUE})
      else
        goto ERROR
      end
    elseif current_char == '"' then
      local val = ""
      while str:sub(index + 1, index + 1) ~= '"' do
        if str:sub(index + 1, index + 1) == "\\" then
          val = val .. "\\"
          if str:sub(index + 2, index + 2) == '"' then
            val = val .. '"'
            index = index + 1
          end
          index = index + 1
        end
        val = val .. str:sub(index + 1, index + 1)
        index = index + 1
      end
      val = unescape_str(val)
      val = '"' .. val .. '"'
      index = index + 1
      tokens:push({ val = val, type = TokenType.STRING})
    elseif current_char:match("[%-%d]") then
      local val = current_char
      local decimal = false
      local exponent = false
      local after_exp = false
      local err = false
      while str:sub(index + 1, index + 1):match("[%d%.eE%-%+]") do
        local next_char = str:sub(index + 1, index + 1)

        if next_char == "." then
          if decimal then
            err = true
          end
          decimal = true
        elseif next_char:match("[eE]") then
          if exponent then
            err = true
          end
          exponent = true
          after_exp = true
        elseif after_exp and next_char:match("[^%-%+%d]") then
          err = true
        end
        val = val .. str:sub(index + 1, index + 1)
        index = index + 1
      end
      if current_char == "-" and #val == 1 then
        err = true
      end
      if val:match("^0%d") then
        err = true
      end
      if err then
        goto ERROR
      else
        tokens:push({ val = val, type = TokenType.NUMBER})
      end
    elseif current_char == "," then
      tokens:push({ val = current_char, type = TokenType.COMMA})
    elseif current_char == ":" then
      tokens:push({ val = current_char, type = TokenType.COLON})
    elseif current_char:match("%s") then
    else
      goto ERROR
    end
    index = index + 1
  end

  return true, tokens, ""
  ::ERROR::
  local content = str:sub(1, index)
  local current_char = content:sub(index, index)
  local line, char = pos_to_line_char(index, content)
  return false, (@sequence(Token))({}), ("ERROR: Unknown token `%s` at line `%d`, character `%d`"):format(current_char, line, char)
end


local file, err = io.open("test.json")

assert(file:isopen(), ("Failed to open file: %s"):format(err))

local content, err = file:read("a")

assert(err == "", err)

local ok, tokens, err = tokenize(content)

assert(ok, err)

for _, token in ipairs(tokens) do
  print(token.val, token_type_tostring(token.type))
end
